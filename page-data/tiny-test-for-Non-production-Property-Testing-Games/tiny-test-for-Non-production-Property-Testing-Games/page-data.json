{"componentChunkName":"component---src-templates-blog-post-js","path":"/tiny-test-for-Non-production-Property-Testing-Games/tiny-test-for-Non-production-Property-Testing-Games/","result":{"data":{"site":{"siteMetadata":{"title":"James Santucci's development blog"}},"markdownRemark":{"id":"4bcbb62f-093c-51b0-8b75-7273fcbe9438","excerpt":"Property testing is a testing strategy where the programmer defers the\nresponsibility of writing example cases to the computer. That’s most of the\ngame, but isn…","html":"<p>Property testing is a testing strategy where the programmer defers the\nresponsibility of writing example cases to the computer. That’s most of the\ngame, but isn’t super useful for practice with property testing outside\nof a production setting.</p>\n<p>Property\ntesting is an area of software development dear to my heart — one of the first\nsoftware talks I ever saw where I thought I’d like to be a developer was on\n<a href=\"https://hypothesis.readthedocs.io/en/latest/\"><code class=\"language-text\">hypothesis</code></a> by <a href=\"https://www.youtube.com/watch?v=jvwfDdgg93E\">Matt Bachmann</a>. However, I’ve often\nhad trouble explaining the mechanics to people without hand-waving. To that end,\nI created <a href=\"https://github.com/jisantuc/tiny-test/\"><code class=\"language-text\">tiny-test</code></a>, a testing framework\nyou <em>absolutely should not use</em> in any production setting, but which is fine for playing\naround.</p>\n<p>What’s the goal with <code class=\"language-text\">tiny-test</code>? Write a “test framework” that illustrates the\n<a href=\"https://en.wikipedia.org/wiki/Stylized_fact\">stylized facts</a> of property testing.</p>\n<h2>What are the stylized facts of property testing frameworks?</h2>\n<p>Property testing goes by a lot of names — <a href=\"https://en.wikipedia.org/wiki/Fuzzing\">fuzz testing</a>, <a href=\"https://medium.com/geckoboard-under-the-hood/how-generative-testing-changed-the-way-we-qa-geckoboard-b4a48a193449\">generative testing</a>,\n<a href=\"https://en.wikipedia.org/wiki/Monkey_testing\">monkey testing</a>… there are a lot. These names collectively emphasize that the test cases\nwill be driven by <em>randomness</em>, so that will be the first stylized fact:\ntest cases in <code class=\"language-text\">tiny-test</code> should be driven by randomness.</p>\n<p>Second, since <code class=\"language-text\">tiny-test</code> is a testing framework, it should have opinions about what\na test is. The second stylized fact is that tests are things that produce test results.\nWhat are test results? Test results are checked expectations — e.g., “I think this\nshould run without crashing,” or “I think the result should be less than six.”</p>\n<p>With these two stylized facts, there’s a pretty straightforward main requirement:\n<code class=\"language-text\">tiny-test</code> needs to provide APIs for transforming randomness into test results. Cool! Let’s\nwork on that.</p>\n<h2>Useful randomness</h2>\n<p>The hello world of property testing is a custom <code class=\"language-text\">add</code> function that acts like the built-in\n<code class=\"language-text\">+</code> operator.</p>\n<p>In Haskell, that would look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">add</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>However, that’s not how <code class=\"language-text\">add</code> is <a href=\"https://github.com/jisantuc/tiny-test/blob/master/src/Lib.hs\">implemented in <code class=\"language-text\">tiny-test</code></a>. How do\nwe explore the possible integer inputs such that we can find the values where the <code class=\"language-text\">add</code> implementation\nis wrong?</p>\n<h3>In Python</h3>\n<p>Let’s suppose we’re working in a language where we can freely mix effectful and non-effectful code,\nlike python. In that case, our test might look something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> random\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">test_add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">assert</span> add<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> a <span class=\"token operator\">+</span> b</code></pre></div>\n<p>Cool, now we can run <em>one test</em> with two random inputs. What if we want to run <em>lots</em> of tests?\nLet’s try that instead:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">test_add_a_lot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    some_as <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    some_bs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>random<span class=\"token punctuation\">.</span>randint<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> a<span class=\"token punctuation\">,</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">zip</span><span class=\"token punctuation\">(</span>some_as<span class=\"token punctuation\">,</span> some_bs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">assert</span> add<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> a <span class=\"token operator\">+</span> b</code></pre></div>\n<p>Nice, now we’ve run <em>lots of tests</em>. This is great because we didn’t have to do very much work and\nwe got to make sure that our <code class=\"language-text\">add</code> function works for lots of different int combinations, instead\nof the six combinations we might come up with in a unit test.</p>\n<p>What if we want to test some property about strings?</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">some_rand_string_fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># This returns a random string, I swear.</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">test_append</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    some_strings <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>some_rand_string_fn<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> st <span class=\"token keyword\">in</span> some_strings<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">assert</span> st <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span>st <span class=\"token operator\">+</span> st<span class=\"token punctuation\">)</span></code></pre></div>\n<p>This pattern looks familiar — generate a bunch of data of the type that we need,\ncall some function on the generated data, and assert some expectation about the result.</p>\n<h2>Properties over arbitrary functions</h2>\n<p>We saw in the Python example that it’s useful to be able to generate data of different types.\nThat example included only <code class=\"language-text\">ints</code> and <code class=\"language-text\">strings</code>, but we could conceivably want to test functions\nwith <em>any</em> input type. In that case, we’d want some way to express the requirements that:</p>\n<ul>\n<li>we can generate data of the type needed</li>\n<li>we have some function on the generated data that gives us a test result</li>\n</ul>\n<p>In languages with typeclasses, we can represent some capability that we want to express like\n“we can generate data of this type” with a <em>typeclass</em>. In property testing libraries, this capability is frequently\n(<a href=\"https://github.com/typelevel/scalacheck/blob/main/src/main/scala/org/scalacheck/Gen.scala\">scalacheck</a>, <a href=\"https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck-Gen.html\">quickcheck</a>, <a href=\"https://hackage.haskell.org/package/hedgehog-1.0.5/docs/Hedgehog-Internal-Gen.html\">hedgehog</a>) wrapped up in a <code class=\"language-text\">Gen</code> type. A value of type <code class=\"language-text\">Gen a</code>\nor <code class=\"language-text\">Gen[A]</code> says “I can generate values of type <code class=\"language-text\">a</code>/<code class=\"language-text\">A</code>.” Often, access to that generator\nis hidden in an <a href=\"https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck-Arbitrary.html\"><code class=\"language-text\">Arbitrary</code> typeclass</a>. In <code class=\"language-text\">tiny-test</code>, we’ll make things a little simpler in\nour <code class=\"language-text\">Arbitrary</code> typeclass,\nand just say that we have a <code class=\"language-text\">sample</code> method that effectfully procures us a list of values\nof the type we want:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">where</span>\n  <span class=\"token hvariable\">sample</span> <span class=\"token operator\">::</span> <span class=\"token constant\">IO</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>The second requirement is simpler — we said tests are things that produce test results, so let’s\nsummon a type called <code class=\"language-text\">Result</code> (the details aren’t important here) and say that we need a function\nfrom something we can summon to a <code class=\"language-text\">Result</code>. In Haskell, that looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">prop</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">IO</span> <span class=\"token constant\">Result</span></code></pre></div>\n<p>Provided you know how to summon values of type <code class=\"language-text\">a</code>, we have a function that we can use to\nrun lots of tests. Let’s assume that <code class=\"language-text\">Results</code> can be combined — in that case, we can smash\nall of our results in the implementation with:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">prop</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">IO</span> <span class=\"token constant\">Result</span>\n<span class=\"token hvariable\">prop</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">do</span>\n  <span class=\"token hvariable\">someAs</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">sample</span>\n  <span class=\"token hvariable\">pure</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">mconcat</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">someAs</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">do</code> takes us into something that looks a little imperative — you can read each line as “this, then\nthat, then the other thing,” similar to languages like Python and JavaScript.\nThe first line says “get me the list of <code class=\"language-text\">a</code>-s that you promised,” and the second says “test them all,\nsmash the results together, and give me the result.” The <code class=\"language-text\">pure $</code> at the beginning is just there to\nmake the types cooperate.</p>\n<p>Similarly, for functions of two parameters where we know how to generate values of both types, we can implement\n<code class=\"language-text\">prop2</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">prop2</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Arbitrary</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">IO</span> <span class=\"token constant\">Result</span>\n<span class=\"token hvariable\">prop2</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">as</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">sample</span>\n    <span class=\"token hvariable\">bs</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">sample</span>\n    <span class=\"token hvariable\">pure</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">fold</span> <span class=\"token operator\">$</span> <span class=\"token builtin\">zipWith</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">as</span> <span class=\"token hvariable\">bs</span></code></pre></div>\n<p>How high can we go with this? All the way to infinity! <code class=\"language-text\">tiny-test</code> stops at <code class=\"language-text\">prop3</code> because that’s not the point of <code class=\"language-text\">tiny-test</code>.\n<em>Real</em> property testing libraries don’t have this kind of limit or require you to count arguments on your own. For example,\nthe <a href=\"https://www.scalacheck.org/#quickstart\"><code class=\"language-text\">ScalaCheck</code> quickstart</a> shows that the <code class=\"language-text\">forAll</code> method, which is like <code class=\"language-text\">prop</code> above, can take functions of different\nnumbers of parameters.</p>\n<h2>Using <code class=\"language-text\">tiny-test</code></h2>\n<p>You can use <code class=\"language-text\">tiny-test</code> in the <code class=\"language-text\">tiny-test</code> test suite. To run the test suite, you’ll need <code class=\"language-text\">stack</code>. If you clone the repo and\nrun <code class=\"language-text\">stack test</code>, you’ll see:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Running test suite addition unit tests\nSuccess!</code></pre></div>\n<p>If you then apply a small diff to the <code class=\"language-text\">Spec.hs</code> file and rerun…</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">diff --git a/test/Spec.hs b/test/Spec.hs\nindex a114364..b776925 100644\n<span class=\"token coord\">--- a/test/Spec.hs</span>\n<span class=\"token coord\">+++ b/test/Spec.hs</span>\n@@ -10,8 +10,8 @@ import TestSuite (TestSuite (..), runTests)\n<span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span>main :: IO ()\n<span class=\"token prefix unchanged\"> </span>main = do\n<span class=\"token prefix unchanged\"> </span>  addUnitExit &lt;- runTestSuite addUnitSuite\n</span><span class=\"token deleted-sign deleted\"><span class=\"token prefix deleted\">-</span>  -- addPropExit &lt;- addPropSuite >>= runTestSuite\n<span class=\"token prefix deleted\">-</span>  exitWith addUnitExit\n</span><span class=\"token inserted-sign inserted\"><span class=\"token prefix inserted\">+</span>  addPropExit &lt;- addPropSuite >>= runTestSuite\n<span class=\"token prefix inserted\">+</span>  exitWith $ addUnitExit `max` addPropExit\n</span><span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span>\n<span class=\"token prefix unchanged\"> </span>runTestSuite :: TestSuite -> IO ExitCode\n<span class=\"token prefix unchanged\"> </span>runTestSuite testSuite =\n</span>@@ -42,12 +42,12 @@ addUnitSuite =\n<span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span>        ]\n<span class=\"token prefix unchanged\"> </span>    }\n<span class=\"token prefix unchanged\"> </span>\n</span><span class=\"token coord\">--- addPropSuite :: IO TestSuite</span>\n<span class=\"token coord\">--- addPropSuite =</span>\n<span class=\"token coord\">---   do</span>\n<span class=\"token coord\">---     result &lt;- Result.fromProp2 (\\x y -> add x y `shouldBe` (x + y))</span>\n<span class=\"token coord\">---     pure $</span>\n<span class=\"token coord\">---       NamedTestSuite</span>\n<span class=\"token coord\">---         { suiteName = \"addition prop tests\",</span>\n<span class=\"token coord\">---           suite = [result]</span>\n<span class=\"token coord\">---         }</span>\n\\ No newline at end of file\n<span class=\"token inserted-sign inserted\"><span class=\"token prefix inserted\">+</span>addPropSuite :: IO TestSuite\n<span class=\"token prefix inserted\">+</span>addPropSuite =\n<span class=\"token prefix inserted\">+</span>  do\n<span class=\"token prefix inserted\">+</span>    result &lt;- Result.fromProp2 (\\x y -> add x y `shouldBe` (x + y))\n<span class=\"token prefix inserted\">+</span>    pure $\n<span class=\"token prefix inserted\">+</span>      NamedTestSuite\n<span class=\"token prefix inserted\">+</span>        { suiteName = \"addition prop tests\",\n<span class=\"token prefix inserted\">+</span>          suite = [result]\n<span class=\"token prefix inserted\">+</span>        }</span></code></pre></div>\n<p>You’ll see a nice collection of failures:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Running test suite addition prop tests\n15 was not equal to 16. Input: (13,3)\n69 was not equal to 70. Input: (13,57)\n34 was not equal to 35. Input: (0,35)\n101 was not equal to 102. Input: (26,76)\n138 was not equal to 139. Input: (91,48)\n76 was not equal to 77. Input: (13,64)\n23 was not equal to 24. Input: (13,11)\n80 was not equal to 81. Input: (0,81)\n103 was not equal to 104. Input: (13,91)\n144 was not equal to 145. Input: (78,67)\n146 was not equal to 147. Input: (52,95)\n94 was not equal to 95. Input: (26,69)\n102 was not equal to 103. Input: (52,51)</code></pre></div>\n<p>If you’re quick with dividing things by 13, you might be suspicious already about how\nthis function was implemented, and of course the implementation in <code class=\"language-text\">tiny-test</code>\nlooks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- |</span>\n<span class=\"token comment\">-- add two numbers</span>\n<span class=\"token comment\">-- but do a bad enough job that property tests show something interesting</span>\n<span class=\"token hvariable\">add</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">add</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">mod</span> <span class=\"token hvariable\">x</span> <span class=\"token number\">13</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token keyword\">else</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">y</span></code></pre></div>\n<p>If you want to play around with other function types, it’s easy to add new arbitrary\ninstances. For example, if you wanted to generate instances of a type <code class=\"language-text\">Foo</code> with a <code class=\"language-text\">num</code> field\nthat’s an <code class=\"language-text\">Int</code> and a <code class=\"language-text\">ch</code> field that’s a <code class=\"language-text\">Char</code>, you could apply the following diff:</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">diff --git a/src/Arbitrary.hs b/src/Arbitrary.hs\nindex 66405b3..17cb6d2 100644\n<span class=\"token coord\">--- a/src/Arbitrary.hs</span>\n<span class=\"token coord\">+++ b/src/Arbitrary.hs</span>\n@@ -10,4 +10,12 @@ class Arbitrary a where\n<span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span>  sample :: IO [a]\n</span>\n<span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span>instance Arbitrary Int where\n</span><span class=\"token deleted-sign deleted\"><span class=\"token prefix deleted\">-</span>  sample = replicateM 100 ((flip mod) 100 &lt;$> randomIO)\n</span>\\ No newline at end of file\n<span class=\"token inserted-sign inserted\"><span class=\"token prefix inserted\">+</span>  sample = replicateM 100 ((flip mod) 100 &lt;$> randomIO)\n<span class=\"token prefix inserted\">+</span>\n<span class=\"token prefix inserted\">+</span>data Foo = Foo { num :: Int, ch :: Char }\n<span class=\"token prefix inserted\">+</span>\n<span class=\"token prefix inserted\">+</span>instance Arbitrary Foo where\n<span class=\"token prefix inserted\">+</span>  sample = replicateM 100 $ do\n<span class=\"token prefix inserted\">+</span>    num &lt;- randomIO\n<span class=\"token prefix inserted\">+</span>    ch &lt;- randomIO\n<span class=\"token prefix inserted\">+</span>    pure $ Foo num ch</span></code></pre></div>\n<p>and test what ever functions over <code class=\"language-text\">Foos</code> you can imagine.</p>","frontmatter":{"title":"tiny-test, for non-production property testing games","date":"March 29, 2021","description":"I wrote a small property testing framework called tiny-test to explore / verify my understanding of / teach property testing."}},"previous":{"fields":{"slug":"/Getting-started-with-STAC-APIs/Getting-started-with-STAC-APIs/"},"frontmatter":{"title":"Getting started with STAC APIs"}},"next":{"fields":{"slug":"/Variable-roles-types-and-code-skimming/Variable-roles-types-and-code-skimming/"},"frontmatter":{"title":"Variable roles, types, and code skimming"}}},"pageContext":{"id":"4bcbb62f-093c-51b0-8b75-7273fcbe9438","previousPostId":"38bdea1b-eb06-5001-ae8a-924e50de8429","nextPostId":"54071118-b669-530a-a861-51cbd56162fe"}},"staticQueryHashes":["2841359383","3257411868"]}