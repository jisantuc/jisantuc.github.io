{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/cliffs,-a-small-CLI-for-remembering-what-your-scripts-to-rule-them-all-are-for/cliffs,-a-small-CLI-for-remembering-what-your-scripts-to-rule-them-all-are-for/",
    "result": {"data":{"site":{"siteMetadata":{"title":"James Santucci's development blog"}},"markdownRemark":{"id":"044a9b46-a101-5f62-bec6-2ef78c2bd4c3","excerpt":"Project I‚Äôve worked on at Azavea really frequently use the Scripts to Rule Them\nAll (STRTA) pattern. Using STRTA is great once everyone is really used to what‚Ä¶","html":"<p>Project I‚Äôve worked on at Azavea really frequently use the <a href=\"https://github.blog/2015-06-30-scripts-to-rule-them-all/\">Scripts to Rule Them\nAll</a> (STRTA) pattern. Using STRTA is great once everyone is really used to what\nall of the scripts are for ‚Äî provided no one has done anything weird, it‚Äôs much\neasier to get spun up in a new project with <code class=\"language-text\">scripts/setup</code> and <code class=\"language-text\">scripts/update</code>\nthan with a bunch of bespoke, one-off commands relying on whatever each project\nis calling a ‚Äúbuild tool.‚Äù</p>\n<p>However, a few weeks ago, someone pointed out that while that‚Äôs nice for\neveryone who is used to STRTA, if the scripts reach a point where no one can\nremember well enough the differences between <code class=\"language-text\">setup</code>, <code class=\"language-text\">bootstrap</code>, and <code class=\"language-text\">update</code>,\nthe scripts can get in the way. You can of course run <code class=\"language-text\">./scripts/setup --help</code>,\n<code class=\"language-text\">./scripts/bootstrap --help</code>, and <code class=\"language-text\">./scripts/update --help</code> provided your\nfriendly colleagues remembered to include a <code class=\"language-text\">--help</code> option, but that ends up\nbeing a lot of typing to do every time.</p>\n<p>Also, over time, the list of available scripts tends to grow much more often\nthan it shrinks. That‚Äôs how in Raster Foundry we wound up with <a href=\"https://github.com/raster-foundry/raster-foundry/tree/develop/scripts\">sixteen\nscripts</a>, most of them non-standard. Some of them aren‚Äôt even useful / don‚Äôt\neven work anymore!</p>\n<p>Something I noticed a bit ago is that some of our projects\nalso have nice tables describing the scripts. I thought: can you use\nsemi-structured READMEs (a bunch of markdown text with a table with special\ncolumn names) and semi-structured scripts (executable text files that ü§ûüèª print\nhelpful information when called with <code class=\"language-text\">--help</code>) to show information about what\nscripts are for in a single interactive location?</p>\n<p>It turns out you can!</p>\n<p>Then an attentive and conscientious human could use that information never to be\nconfused about what scripts are for and to have an up-to-date view of all the\nscripts that are still around.</p>\n<p>I think I probably poisoned my brain and I‚Äôm now seeing every problem as a\nterminal UI problem, but I think it was worth it to learn a fun new tool.</p>\n<h2><code class=\"language-text\">cliffs</code></h2>\n<p><a href=\"https://github.com/jisantuc/cliffs\"><code class=\"language-text\">cliffs</code></a> is a small CLI that does very little, but the little it does is\npretty useful. If you have a README with specially named columns and a scripts\ndirectory named <code class=\"language-text\">scripts</code>, running <code class=\"language-text\">cliffs</code> will get you a nice little\ninteractive session for exploring what each thing does:</p>\n<p>\n        <div class=\"embedVideo-container\">\n            <iframe\n              title=\"\"\n              width=\"560\"\n              height=\"316\"\n              src=\"https://www.youtube.com/embed/8DwItA-1YnU?rel=0\"\n              class=\"embedVideo-iframe\"\n              style=\"border:0\"\n              \n              loading=\"eager\"\n              allowfullscreen\n\t      sandbox=\"allow-same-origin allow-scripts allow-popups\"\n            ></iframe>\n        </div></p>\n<p>In short:</p>\n<ul>\n<li>run <code class=\"language-text\">cliffs</code> in a directory containing a README.md file and a <code class=\"language-text\">scripts/</code>\ndirectory</li>\n<li>‚¨ÜÔ∏è/‚¨áÔ∏è to preview the <code class=\"language-text\">--help</code> text for a script</li>\n<li>or you can just look at descriptions if they‚Äôre sufficient</li>\n</ul>\n<p>I think you could use <code class=\"language-text\">cliffs</code> either to help you find out what scripts are for\nif you‚Äôve forgotten or to audit your scripts to make sure they all understand\nwhat the <code class=\"language-text\">--help</code> flag does. While frameworks like Python‚Äôs <code class=\"language-text\">click</code> or <code class=\"language-text\">oclif</code>\nin Node.js will handle <code class=\"language-text\">--help</code> for you, if you‚Äôre hand-rolling bash scripts,\nit‚Äôs much easier to forget. </p>\n<p>You can install cliffs with <a href=\"https://nixos.org/download.html\"><code class=\"language-text\">nix</code></a> as:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">nix-env -i -f https://github.com/jisantuc/cliffs/archive/refs/tags/v0.0.1.zip</code></pre></div>\n<p>Someday there will be a container image, but I don‚Äôt actually know how to turn\nmy <code class=\"language-text\">default.nix</code> into a container yet ü§∑üèª‚Äç‚ôÇÔ∏è.</p>\n<p><code class=\"language-text\">cliffs</code> is built on‚Ä¶</p>\n<h3><a href=\"https://github.com/jtdaugherty/brick\"><code class=\"language-text\">brick</code></a></h3>\n<p><a href=\"https://github.com/jtdaugherty/brick\"><code class=\"language-text\">brick</code></a> handles the terminal UI interactions. <code class=\"language-text\">brick</code> was a delight to get\nstarted with and felt like writing <a href=\"https://guide.elm-lang.org/architecture/\">The Elm Architecture</a> for a terminal\nprogram. As someone whose brain breaks every time I have to think about frontend\nlayout, getting live in a land of pure functions from state to UI was really\nnice. Also, the <a href=\"https://github.com/jtdaugherty/brick/tree/master/programs\">examples directory</a> was really effective as documentation.</p>\n<h3><a href=\"https://hackage.haskell.org/package/cmark-gfm-0.2.2\"><code class=\"language-text\">cmark-gfm</code></a></h3>\n<p><a href=\"https://hackage.haskell.org/package/cmark-gfm-0.2.2\"><code class=\"language-text\">cmark-gfm</code></a> stands for ‚ÄúCommonMark GitHub-flavored markdown‚Äù. It‚Äôs the library\nresponsible for turning raw text into something with some structure. It‚Äôs\noriented around nodes and their children, which means for any sort of search for\na specific kind of element, we just have to walk a tree and find a node matching\nsome predicate. It claims to be <em>very fast</em>, which is nice, but didn‚Äôt really\ncome up for the READMEs I tested on. If you can describe in words the\nrelationships between the things you‚Äôre looking for ‚Äî e.g. ‚Äúthe text in the\nsecond column of the row‚Äù ‚Äî it‚Äôs not super difficult to guess the relationships\nbetween nodes that you end up with after parsing with <code class=\"language-text\">cmark-gfm</code>.</p>\n<p>A surprising bonus is that parsing <a href=\"https://hackage.haskell.org/package/cmark-gfm-0.2.2/docs/CMarkGFM.html#v:commonmarkToNode\"><em>can‚Äôt fail</em></a> ‚Äî note that the return type\nfor <code class=\"language-text\">commonmarkToNode</code> doesn‚Äôt return an <code class=\"language-text\">Either</code> or <code class=\"language-text\">Option</code> or <code class=\"language-text\">IO</code> of <code class=\"language-text\">Node</code>,\njust a <code class=\"language-text\">Node</code>. I hadn‚Äôt considered this before, but the reason for this is that\nthere‚Äôs no such thing as an invalid CommonMark document ‚Äî the <a href=\"https://spec.commonmark.org/0.30/#why-is-a-spec-needed-\">CommonMark spec</a>\neven notes that</p>\n<blockquote>\n<p>nothing in Markdown counts as a ‚Äúsyntax error‚Äù</p>\n</blockquote>\n<p>I hadn‚Äôt considered this previously and it was cool to learn something about\nsomething I use almost <em>every day</em> from the return type of a parser.</p>","frontmatter":{"title":"cliffs, a small CLI for remembering what your scripts to rule them all are for","date":"November 23, 2021","description":"Scripts to rule them all is a nice pattern that was cool and fresh and on\neveryone's mind several years ago. However, now time has passed, and it can\nbe hard to remember what all the scripts are for. `cliffs` is a small terminal\nUI that helps with that.\n"}},"previous":{"fields":{"slug":"/Variable-roles-types-and-code-skimming/Variable-roles-types-and-code-skimming/"},"frontmatter":{"title":"Variable roles, types, and code skimming"}},"next":null},"pageContext":{"id":"044a9b46-a101-5f62-bec6-2ef78c2bd4c3","previousPostId":"54071118-b669-530a-a861-51cbd56162fe","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}